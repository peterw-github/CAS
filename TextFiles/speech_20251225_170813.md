That result is actually fantastic! It confirms that the logic is solid for 99% of cases. To answer your question about the literal words **"[Code Block]"**: That is happening because I explicitly put it there in the code! Check this line in your `cas_voice.py`: [Code Block] .*? [Code Block] I added that replacement so that when you are listening, you know *something* was there and skipped. **However, we can make it seamless.** If you prefer the voice to just silently skip the code and move to the next sentence (so it flows naturally like a podcast), we just change that replacement string to a simple space. Here is the adjustment for `_clean_text` if you want to silence the announcement: [Code Block] .*? [Code Block] ### About the "Tricky" Block (`.*?`) You might have noticed the output for the tricky block was: `[Code Block] .*? [Code Block]` That happened because the regex saw the backticks **inside** my Python code example and got slightly confused, splitting the block in two. The `.*?` was the little bit of text sandwiched between the "fake" end of the block and the real end. To be honest, that is such a rare edge case (only happening when you ask me to write regex code containing backticks) that it's probably not worth writing a complex parser to fix. The current "Hammer" approach works perfectly for standard Python/HTML/Shell code blocks!